}
# если не длинный, и группа не является последней, и группа не является первой
# то классифицируем пропуск по близости сэмплов, смежных с пропуском
if (gapLen <= maxGapLen & gr != length(eventGroups) & !is.na(lastGroup))
{
if (lastGroup != evm@markerNames$gap & eventGroups[[gr+1]]$evm[1] != evm@markerNames$gap)
{
lastSmpBeforeGap <- eventGroups[[gr-1]][nrow(eventGroups[[gr-1]]),]
firstSmpAfterGap <- eventGroups[[gr+1]][1,]
t1 <- lastSmpBeforeGap$t
t2 <- firstSmpAfterGap$t
pos1 <- c(lastSmpBeforeGap$x, lastSmpBeforeGap$y)
pos2 <- c(firstSmpAfterGap$x, firstSmpAfterGap$y)
if (t2-t1 <= MaxTBetFix)
{
dist <- sqrt((pos1[1]-pos2[1])^2 + (pos1[2]-pos2[2])^2)
# если смежные с пропуском сэмплы близки во времени и пространстве,
# то он классифицируется как фиксация
if (dist <= MaxDistBetFix)
{
gapClass <- evm@markerNames$fixation
}
else
# если не близки в пространстве, то пропуск классифицируется как саккада
{
gapClass <- evm@markerNames$saccade
}
}
else
# если не близки во времени, то пропуск классифицируется как саккада
{
gapClass <- evm@markerNames$saccade
}
}
if (lastGroup == evm@markerNames$gap | eventGroups[[gr+1]]$evm[1] == evm@markerNames$gap)
{
gapClass <- evm@markerNames$gap
}
}
}
else
{
gapClass <- evm@markerNames$gap
}
# результат классификации пропуска позволяет отнести его сэмплы к тому или иному списку событий
# если пропуск - длинный пропуск, то пополняем список пропусков
if (gapClass == evm@markerNames$gap)
{
gapGroups <- append(gapGroups, eventGroups[gr])
lastGroup <- evm@markerNames$gap
eventMarkersGroups <- append(eventMarkersGroups, rep(evm@markerNames$gap, nrow(eventGroups[[gr]])))
}
# если пропуск - фиксация
if (gapClass == evm@markerNames$fixation)
{
# то если последняя группа - фиксация, то добавляем сэмплы пропуска в эту группу
if (lastGroup == evm@markerNames$fixation)
{
lastFixation <- rbind(eventGroups[[gr-1]], eventGroups[[gr]])
fixationGroups[length(fixationGroups)] <- list(lastFixation)
lastGroup <- evm@markerNames$fixation
eventMarkersGroups <- append(eventMarkersGroups, rep(evm@markerNames$fixation, nrow(eventGroups[[gr]])))
}
# иначе добавляем новую группу в список фиксаций
else
{
fixationGroups <- append(fixationGroups, eventGroups[gr])
lastGroup <- evm@markerNames$fixation
eventMarkersGroups <- append(eventMarkersGroups, rep(evm@markerNames$fixation, nrow(eventGroups[[gr]])))
}
}
# если пропуск - саккада
if (gapClass == evm@markerNames$saccade)
{
# то если последняя группа - саккада, то добавляем сэмплы пропуска в эту группу
if (lastGroup == evm@markerNames$saccade)
{
lastSaccade <- rbind(eventGroups[[gr-1]], eventGroups[[gr]])
saccadeGroups[length(saccadeGroups)] <- list(lastSaccade)
lastGroup <- evm@markerNames$saccade
eventMarkersGroups <- append(eventMarkersGroups, rep(evm@markerNames$saccade, nrow(eventGroups[[gr]])))
}
# иначе добавляем новую группу в список саккад
if (lastGroup == evm@markerNames$fixation | lastGroup == evm@markerNames$gap)
{
saccadeGroups <- append(saccadeGroups, eventGroups[gr])
lastGroup <- evm@markerNames$saccade
eventMarkersGroups <- append(eventMarkersGroups, rep(evm@markerNames$saccade, nrow(eventGroups[[gr]])))
}
}
}
}
evm@eventMarkers <- unlist(eventMarkersGroups)
evm@eventGroups <- group
}
return(evm)
}
ANH <- function(t, x, y, filterMarkers, settings) {
angular <- settings$angular
screenDist <- settings$screenDistance
screenResolution <- settings$screenResolution
screenSize <- settings$screenSize
postProcess <- settings$postProcess
velType <- settings$velType
fl <- settings$fl
fs <- settings$sampleRate
if (is.na(fs))
{
meandt <- mean(t[-1] - t[-length(t)], na.rm = T)
fs <- 1/meandt
}
screenDist <- settings$screenDistance
screenResolution <- settings$screenResolution
screenSize <- settings$screenSize
angular <- settings$angular
velType <- settings$velType
fl <- settings$fl
fs <- settings$sampleRate
size <- length(t)
if (is.na(fs))
{
meandt <- mean(t[-1] - t[-size], na.rm = T)
fs <- 1/meandt
}
maxSaccadeVel  <- settings$maxSaccadeVel
maxSaccadeAcc  <- settings$maxSaccadeAcc
minSaccadeDur  <- settings$minSaccadeDur
minFixationDur <- settings$minFixationDur
# Using Savitsky-Golay filter to get velocities and accelerations using derivatves of approximated x and y signals
vel <- calcVel(t, x, y, settings)
accels <- vel$accels
evm <- new(Class = "EventMarkers")
rawEvM <- ifelse(filterMarkers@filterMarkers != filterMarkers@markerNames$ok, "Gap", "Not Gap")[-size]
windowSize <- floor(minFixationDur/mean(vel$dts, na.rm = T))
### Peak velocity Threshold calculation
getThreshold <- function(Vel,PT0,tolerance,sigmaCoef) {
PT <- PT0
repeat {
PTcur <- PT
m <- mean(Vel[which(Vel<PTcur)], na.rm = T)
s <- sd(Vel[which(Vel<PTcur)], na.rm = T)
PT <- m + sigmaCoef*s
if (abs(PT - PTcur) < tolerance) {break}
}
PT
}
getThreshold3 <- function(Vel,PT0,tolerance) {
PT <- PT0
repeat {
PTcur <- PT
m <- mean(Vel)
s <- sd(Vel)
PT <- m + 3*s
if (abs(PT - PTcur) < tolerance) {break}
}
PT
}
PT <- getThreshold(vel$vels[which(rawEvM == "Not Gap")], PT0 = 250, tolerance = 0.1, sigmaCoef = 6)
### Saccades detection
### Velocity peaks, saccades onsets and offsets search
#Находим номера сэмплов начала пика и конца пика
above_Threshold <- (vel$vels > PT)
peaks <- which(above_Threshold[-1]!=above_Threshold[-length(above_Threshold)])
if (peaks[1]<=windowSize) peaks <- peaks[-c(1:2)]
#Находим onset-ы
STon <- getThreshold(vel$vels[which(rawEvM == "Not Gap")], PT0 = 250, tolerance = 0.1, sigmaCoef = 3)
leftmost_peaks <- peaks[seq(1,length(peaks),2)]
onsets <- c()
for (i in leftmost_peaks){
nsample <- i
if (nsample <= windowSize) break
repeat {
if (vel$vels[nsample] < STon)
if ((vel$vels[nsample]-vel$vels[nsample-1]) <= 0) {
onsets <- c(onsets, nsample)
break
}
else if((nsample-1)==0) break
else nsample <- nsample - 1
else nsample <- nsample - 1
}
}
#Находим offset-ы
rightmost_peaks <- peaks[seq(2,length(peaks),2)]
offsets <- c()
offset_Thresholds <- c()
alpha <- 0.7; beta <- 0.3
for (i in 1:length(rightmost_peaks)) {
nsample <- rightmost_peaks[i]
from <- (onsets[i]-windowSize)
to <- onsets[i]
LNT <- getThreshold3(vel$vels[from:to], PT0 = 250, tolerance = 0.1)
SToff <- alpha*STon + beta*LNT
offset_Thresholds <- c(offset_Thresholds, SToff)
repeat {
if (vel$vels[nsample] < SToff)
if ((vel$vels[nsample] - vel$vels[nsample+1]) <= 0) {
offsets <- c(offsets, nsample)
break
}
else nsample <- nsample + 1
else nsample <- nsample + 1
if((nsample)>=size) break
}
}
### Saccade detection
for (i in 1:length(offsets))
if (sum(vel$dts[onsets[i]:offsets[i]])>minSaccadeDur)
rawEvM[onsets[i]:offsets[i]] <- ifelse(rawEvM[onsets[i]:offsets[i]]=="Gap",evm@markerNames$gap, evm@markerNames$saccade)
### Glissade detection
for (i in 1:length(offsets)) {
n <- ifelse((offsets[i]+windowSize)>=size,size-1,offsets[i]+windowSize)
for (j in offsets[i]:n) {
if (rawEvM[j]=="Not Gap")
rawEvM[j] <- ifelse((vel$vels[j] > PT),
evm@markerNames$glissade, #HighVelGlissade
ifelse(vel$vels[j] > offset_Thresholds[i],
evm@markerNames$glissade, #LowVelGlissade
evm@markerNames$gap))
}
}
############################
### Fixation detection ###
############################
rawEvM <- ifelse(rawEvM == "Not Gap", evm@markerNames$fixation, rawEvM)
evmarks <- data.frame(firstEv = rawEvM[-length(rawEvM)], secondEv = rawEvM[-1])
transitions <- apply(evmarks, MARGIN = 1, function(x) {if (x[2] != x[1]) {1} else {0}})
group <- c(1,cumsum(transitions)+1)
evm@eventMarkers <- rawEvM
evm@eventGroups <- group
return(evm)
}
IDT <- function(t, x, y, filterMarkers, settings) {
dispersionThreshold <- settings$dispersionThreshold # in px or degrees
durationThreshold <- settings$durationThreshold # in milliseconds
durationThreshold <- durationThreshold/1000 # now in seconds
angular <- settings$angular
screenDist <- settings$screenDist
screenResolution <- settings$screenResolution
screenSize <- settings$screenSize
if (angular)
{
angPositions <- calcAngPos(x = x, y = y, screenDist, screenResolution, screenSize)
x <- angPositions$xAng
y <- angPositions$yAng
}
evm <- new(Class = "EventMarkers")
size <- length(t)
rawEvM <- c()
rawEvM[1:(size-1)] <- evm@markerNames$saccade
coords <- data.frame(x=x[-size], y=y[-size], dur= t[-1]-t[-size])
left <- 1; right <- 2
while (right < size) {
if (sum(coords$dur[left:right]) < durationThreshold) right <- right + 1
else {
d <- (max(coords$x[left:right])-min(coords$x[left:right]))+(max(coords$y[left:right])-min(coords$y[left:right]))
if (d > dispersionThreshold) {
left <- right + 1
# left <- left + 1
right <- left + 1
}
else {
while ((d <= dispersionThreshold) & (right<size)) {
right <- right + 1
d <- (max(coords$x[left:right])-min(coords$x[left:right]))+(max(coords$y[left:right])-min(coords$y[left:right]))
}
right <- right - 1
rawEvM[left:right] <- evm@markerNames$fixation
left <- right + 1
right <- left + 1
}
}
}
rawEvM[which(filterMarkers@filterMarkers != filterMarkers@markerNames$ok)[-size]] <- "Gap"
evmarks <- data.frame(firstEv = rawEvM[-length(rawEvM)], secondEv = rawEvM[-1])
transitions <- apply(evmarks, MARGIN = 1, function(x) {if (x[2] != x[1]) {1} else {0}})
group <- c(1,cumsum(transitions)+1)
evm@eventMarkers <- rawEvM
evm@eventGroups <- group
return(evm)
}
settingsIVT <- list(VT               = 30, # in deg/second if angular is TRUE (30 is a standard value, rule of thumb)
postProcess      = F, # do not touch
# the next args are used to calculate angular positions and velocity
angular          = T,
screenDist       = 50, # cm
screenSize       = c(30, 20), # cm
screenResolution = c(1280,1024), # px
velType          = "analytical", #finDiff
sampleRate       = 500, # Hz
fl               = 20 # msec
)
settingsIDT <- list(dispersionThreshold = 1/2, # minimum DT in IDT algorithm! (see Identifying Fixations and Saccades in Eye-Tracking Protocols)
durationThreshold   = 100, # minimum DurationT in IDT algorithm (-||-)
# the next args are used to calculate angular positions and velocity
angular          = T,
screenDist       = 50, # cm
screenSize       = c(30, 20), # cm
screenResolution = c(1280,1024), # px
velType          = "analytical", #finDiff
sampleRate       = 500, # Hz
fl               = 20 # msec
)
settingsANH <- list(maxSaccadeVel    = 1000, # deg/s (all args for ANH are set to recommended values)
maxSaccadeAcc    = 100000, # deg/s^2
minSaccadeDur    = 0.01, # seconds
minFixationDur   = 0.04, # seconds
PT0              = 0.250, # seconds
tolerance        = 0.00001, # seconds
# the next args are used to calculate angular positions and velocity
angular          = T,
screenDist       = 50, # cm
screenSize       = c(30, 20), # cm
screenResolution = c(1280,1024), # px
velType          = "analytical", #finDiff
sampleRate       = 500, # Hz
fl               = 20 # msec
)
#-----------------------------------Визуализация----------------------------
mainpath <- "F:\\Институт\\Проекты\\EyeTrackingPackage\\Data\\Tower-mounted SMI\\"
filepath <- paste(mainpath,"Marmalyuk_Yuriev_problem_solving_Lugancov_1232_Trial001 Samples.txt", sep="")
test_data = read.csv(file = filepath, header = T, dec = ".", comment.char = "#", sep = "\t")[-1,]
t <- test_data$Time/1000000 # !!! Need to convert time to seconds !!!
x <- test_data$L.POR.X..px. # !!! NOT RAW X !!!
y <- test_data$L.POR.Y..px. # !!! NOT RAW Y !!!
### Checking velocity plot
velos <- calcVel(t,x,y,settings)
plot(velos$vels)
### Detecting events
ANHdata <- ANH(t,x,y,0,settings)
IDTdata <- IDT(t,x,y,filterMarkers = new(Class = "FilterMarkers", filterMarkers = rep("Ok", length(t))), settingsIDT)
IVTData <- IVT(t, x, y, filterMarkers = new(Class = "FilterMarkers", filterMarkers = rep("Ok", length(t))), settingsIVT)
indexes <- 80:180
leg_posANH <- c(.82,.84)
leg_posIDT <- c(.82,.91)
IVT_coords_plot <- qplot(x[indexes],y[indexes],
colour = IVTData@eventMarkers[indexes],
size = I(3),
main = "IVT, координаты",
xlab = "x координата",
ylab = "y координата") +
scale_colour_manual(labels = c("Фиксация","Саккада"),
values = c("black", "red")) +
theme(legend.position=leg_posANH,
legend.title=element_blank())
IVTplot <- qplot(indexes,velos$vels[indexes],
colour = IVTData@eventMarkers[indexes],
size = I(4),
main = "IVT, скорости",
xlab = "Время",
ylab = "Скорость") +
scale_colour_manual(labels = c("Фиксация","Саккада"),
values = c("black", "red")) +
theme(legend.position=leg_posANH,
legend.title=element_blank())
ANH_coords_plot <- qplot(x[indexes],y[indexes],
colour = ANHdata@eventMarkers[indexes],
size = I(3),
main = "AdaptiveNH, координаты",
xlab = "x координата",
ylab = "y координата") +
scale_colour_manual(labels = c("Фиксация","Артефакт","Глиссада","Саккада"),
values = c("black",   "green",  "blue",    "red")) +
theme(legend.position=leg_posANH,
legend.title=element_blank())
ANHplot <- qplot(indexes,velos$vels[indexes],
colour = ANHdata@eventMarkers[indexes],
size = I(4),
main = "AdaptiveNH, скорости",
xlab = "Время",
ylab = "Скорость") +
scale_colour_manual(labels = c("Фиксация","Артефакт","Глиссада","Саккада"),
values = c("black",   "green",  "blue",    "red")) +
theme(legend.position=leg_posANH,
legend.title=element_blank())
IDT_coords_plot <- qplot(x[indexes],y[indexes],
colour = IDTdata@eventMarkers[indexes],
size = I(3),
main = "IDT, координаты",
xlab = "x координата",
ylab = "y координата") +
scale_colour_manual(labels = c("Фиксация","Саккада"),
values = c("black",   "red")) +
theme(legend.position=leg_posIDT,
legend.title=element_blank())
IDTplot <- qplot(indexes,velos$vels[indexes],
colour = IDTdata@eventMarkers[indexes],
size = I(4),
main = "IDT, скорости",
xlab = "Время",
ylab = "Скорость") +
scale_colour_manual(labels = c("Фиксация","Саккада"),
values = c("black",   "red")) +
theme(legend.position=leg_posIDT,
legend.title=element_blank())
grid.arrange(IVT_coords_plot,IVTplot,
ANH_coords_plot,ANHplot,
IDT_coords_plot,IDTplot)
settingsVels <- list(#the next args are used to calculate angular positions and velocity
angular          = T,
screenDist       = 50, # cm
screenSize       = c(30, 20), # cm
screenResolution = c(1280,1024), # px
velType          = "analytical", #finDiff
sampleRate       = 500, # Hz
fl               = 20 # msec
)
settingsIVT <- list(VT               = 30, # in deg/second if angular is TRUE (30 is a standard value, rule of thumb)
postProcess      = F # do not touch
)
settingsIDT <- list(dispersionThreshold = 1/2, # minimum DT in IDT algorithm! (see Identifying Fixations and Saccades in Eye-Tracking Protocols)
durationThreshold   = 100 # minimum DurationT in IDT algorithm (-||-)
)
settingsANH <- list(maxSaccadeVel    = 1000, # deg/s (all args for ANH are set to recommended values)
maxSaccadeAcc    = 100000, # deg/s^2
minSaccadeDur    = 0.01, # seconds
minFixationDur   = 0.04, # seconds
PT0              = 0.250, # seconds
tolerance        = 0.00001 # seconds
)
IDTdata <- IDT(t,x,y,filterMarkers = new(Class = "FilterMarkers", filterMarkers = rep("Ok", length(t))), append(settingsIDT, settingsVels)
IDTdata <- IDT(t,x,y,filterMarkers = new(Class = "FilterMarkers", filterMarkers = rep("Ok", length(t))), append(settingsIDT, settingsVels))
ANHdata <- ANH(t,x,y,0,append(settingsANH, settingsVels))
ANHdata <- ANH(t,x,y,filterMarkers = fm,append(settingsANH, settingsVels))
fm <- new(Class = "FilterMarkers", filterMarkers = rep("Ok", length(t)))
ANHdata <- ANH(t,x,y,filterMarkers = fm,append(settingsANH, settingsVels))
library(data.table)
library(signal)
library(shiny)
library(shinydashboard)
library(devtools)
library(DT)
library(htmlwidgets)
library(D3TableFilter)
# options(shiny.maxRequestSize = 1000*1024^2)
runApp("F:\\Институт\\Проекты\\EyeTrackingPackage\\Git\\EyeTrackingProject\\Shiny")
j <- function(theta)
{
3*theta^4 + 4
}
j(1.01)
(j(1.01)-j(0.99))/(2*0.01)
exp(rnorm(n = 10, mean = 1, sd = 2))
hist(exp(rnorm(n = 1000, mean = 1, sd = 2)))
hist(exp(rnorm(n = 1000, mean = 1, sd = 2)), breaks = 100)
hist(exp(rnorm(n = 1000, mean = 10, sd = 2)), breaks = 100)
hist(exp(rnorm(n = 1000, mean = 10, sd = 3)), breaks = 100)
hist(exp(rnorm(n = 1000, mean = 10, sd = 3)), breaks = 1000)
hist(exp(rnorm(n = 1000, mean = 10, sd = 3)), breaks = 100)
hist(exp(rnorm(n = 1000, mean = 10, sd = 3)), breaks = 100, xlim = c(0,100))
hist(exp(rnorm(n = 1000, mean = 10, sd = 3)), breaks = 100, xlim = c(0,1000))
hist(exp(rnorm(n = 1000, mean = 1, sd = 3)), breaks = 100, xlim = c(0,1000))
hist(exp(rnorm(n = 1000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,1000))
hist(exp(rnorm(n = 1000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,100))
hist(exp(rnorm(n = 1000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
hist(exp(rnorm(n = 10000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 10000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 10000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 10000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 10000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
mean(exp(rnorm(n = 1000000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
hist(exp(rnorm(n = 10000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,300))
hist(exp(rnorm(n = 10000, mean = 1, sd = 3)), breaks = 1000, xlim = c(0,3000))
library(data.table)
library(signal)
library(shiny)
library(shinydashboard)
library(devtools)
library(DT)
library(htmlwidgets)
library(D3TableFilter)
# options(shiny.maxRequestSize = 1000*1024^2)
runApp("F:\\Институт\\Проекты\\EyeTrackingPackage\\Git\\EyeTrackingProject\\Shiny")
runApp("F:\\Институт\\Проекты\\EyeTrackingPackage\\Git\\EyeTrackingProject\\Shiny")
list('Trajectory Duration' = 10)
library(data.table)
library(signal)
library(shiny)
library(shinydashboard)
library(devtools)
library(DT)
library(htmlwidgets)
library(D3TableFilter)
runApp("F:\\Институт\\Проекты\\EyeTrackingPackage\\Git\\EyeTrackingProject\\Shiny")
runApp("F:\\Институт\\Проекты\\EyeTrackingPackage\\Git\\EyeTrackingProject\\Shiny")
list(a = 1, a = 2 )
runApp("F:\\Институт\\Проекты\\EyeTrackingPackage\\Git\\EyeTrackingProject\\Shiny")
library(data.table)
library(signal)
library(shiny)
library(shinydashboard)
library(devtools)
library(DT)
library(htmlwidgets)
library(D3TableFilter)
# options(shiny.maxRequestSize = 1000*1024^2)
runApp("F:\\Институт\\Проекты\\EyeTrackingPackage\\Git\\EyeTrackingProject\\Shiny")
